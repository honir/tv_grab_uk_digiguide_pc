#!/usr/bin/perl -w
#
# Copyright G. Westcott - January 2014
#
# This code is distributed under the GNU General Public License v2 (GPLv2) .
#
#   For extended help information run
#         tv_grab_uk_dgpc  --info
#
# 

my $_version 	= '$Id: tv_grab_uk_dgpc,v 1.0 2014/01/31 13:09:34 bilbo_uk Exp $';

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use strict;
use warnings;
use constant { true => 1, false => 0 };
use Data::Dumper;

use XMLTV::ProgressBar;
use XMLTV::Options qw/ParseOptions/;
use XMLTV::Configure::Writer;
use XMLTV::Supplement 0.005065 qw/SetSupplementRoot GetSupplementDir GetSupplementLines/;
use XMLTV::Get_nice 0.005065 qw/get_nice get_nice_tree/;

use File::Path;
use POSIX qw(strftime);
use DateTime;
use Date::Parse;
use URI::Escape;
use Encode;

my $usecache = 0;
if ($usecache) { require HTTP::Cache::Transparent; import HTTP::Cache::Transparent; }

my $usecookies = 0;
if ($usecookies) { 
	require HTTP::Cookies;
	my $cookies = HTTP::Cookies->new;
	$XMLTV::Get_nice::ua->cookie_jar($cookies);
}


# Although we use HTTP::Cache::Transparent, this undocumented --cache
# option for debugging is still useful since it will _always_ use a
# cached copy of a page, without contacting the server at all.
#
use XMLTV::Memoize; XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');

use subs qw(debug warning);
my $warnings = 0;

# ------------------------------------------------------------------------------------------------------------------------------------- #
# Grabber details
my $VERSION 								= $_version;
my $GRABBER_NAME 						= 'tv_grab_uk_dgpc';
my $GRABBER_DESC 						= 'UK - Digiguide PC (http://digiguide.tv/products/windows.asp)';
my $GRABBER_URL 						= 'http://wiki.xmltv.org/index.php/XMLTVProject';
my $ROOT_URL                = 'http://localhost:2402/';
my $SOURCE_NAME							= 'Digiguide PC';
my $SOURCE_URL							= 'http://digiguide.tv/';
#
my $generator_info_name 		= $GRABBER_NAME;
my $generator_info_url 			= $GRABBER_URL;
my $source_info_name				= $SOURCE_NAME;
my $source_info_url					= $SOURCE_URL;
#



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Use XMLTV::Options::ParseOptions to parse the options and take care of the basic capabilities that a tv_grabber should
my ($opt, $conf) = ParseOptions({ 
			grabber_name 			=> $GRABBER_NAME,
			capabilities 			=> [qw/baseline manualconfig apiconfig cache/],
			stage_sub 				=> \&config_stage,
			listchannels_sub 	=> \&list_channels,
			version 					=> $VERSION,
			description 			=> $GRABBER_DESC,
});

#print Dumper($conf); exit;

# any overrides?
if (defined( $conf->{'generator-info-name'} )) { $generator_info_name = $conf->{'generator-info-name'}->[0]; }
if (defined( $conf->{'generator-info-url'} ))  { $generator_info_url  = $conf->{'generator-info-url'}->[0]; }
if (defined( $conf->{'source-info-name'} )) 	 { $source_info_name 		= $conf->{'source-info-name'}->[0]; }
if (defined( $conf->{'source-info-url'} ))  	 { $source_info_url 		= $conf->{'source-info-url'}->[0]; }

$ROOT_URL  = 'http://'.$conf->{'digiguide_ip'}->[0].':'.$conf->{'digiguide_port'}->[0].'/';
my $dgsid;
my $src_encoding = 'windows-1252';



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Initialise the web page cache
if ($usecache) { 
	init_cachedir( $conf->{cachedir}->[0] );
	HTTP::Cache::Transparent::init( { 
			BasePath => $conf->{cachedir}->[0],
			NoUpdate => 60*60,			# cache time in seconds
			MaxAge => 24,						# flush time in hours
			Verbose => $opt->{debug},
	} );
}



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Check we have all our required conf params
config_check();



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Progress Bar :)
my $barcount = ( $conf->{'method'}[0] eq 'multi' ) 
	? ( 100 )                                                   # can't determine yet since we don't know how many channels in the grid
	: ( (scalar @{$conf->{channel}}) * ($opt->{days} + 1) );    # +1 added for the extra day necessary for <06:00 programmes
my $bar = new XMLTV::ProgressBar({
  name => "Fetching listings",
  count => $barcount,
}) unless ($opt->{quiet} || $opt->{debug});



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Data store before being written as XML
my $programmes = ();
my $channels = ();
my %progtimes = ();


# make sure there's a delay between http requests - in testing I was getting strange errors if I sent requests
# too fast (it would return a 200 but with 0 content-length)
$XMLTV::Get_nice::Delay = 0; $XMLTV::Get_nice::MinDelay = 2;

# Get the schedule(s) from TV Guide
fetch_listings();

# print Dumper($programmes);



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Progress Bar
$bar->finish() && undef $bar if defined $bar;



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Filter out programmes outside of requested period (see man page)
my %w_args;
if (($opt->{offset} != 0) || ($opt->{days} != -999)) {
  $w_args{offset} = $opt->{offset};
  $w_args{days} = ($opt->{days} == -999) ? 100 : $opt->{days};
  $w_args{cutoff} = '000000';			# e.g. '060000'
}



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Generate the XML
my $encoding = 'UTF-8';
my $credits = { 'generator-info-name' => $generator_info_name,
								'generator-info-url' 	=> $generator_info_url,
								'source-info-name' 		=> $source_info_name,
								'source-info-url' 		=> $source_info_url };
	
XMLTV::write_data([ $encoding, $credits, $channels, $programmes ], %w_args);
# Finished!



# ------------------------------------------------------------------------------------------------------------------------------------- #
# Signal that something went wrong if there were warnings.
exit(1) if $warnings;

# All data fetched ok.
debug "Exiting without warnings.";
exit(0);


# ####################################################################
# # THE MEAT ############################################################
# ------------------------------------------------------------------------------------------------------------------------------------- #

# There are 3 key subs:
#		fetch_listings()  - main control loop which gets the web pages required to fulfill the runtime params
#		extract_schedule() - parses the fetched page and extracts the relevant data into a hash ( %prog )
#  	add_programme_to_xml() - takes the %prog hash and formats into a structure xmltv will understand ( %xmlprog ), 
#		                                        and then adds that to our main programmes array ( @{$programmes} )
#

sub fetch_listings {
		# Fetch listings for requested channels
		
		# Are we logged-in?
		if (!defined $dgsid) { 
			log_in($conf, $opt); 
			if (!defined $dgsid) { 
				# (note: we won't see this message: get_nice will barf with a 'could not fetch ...' error 500 before here)
				print 'Unable to log-in to Digiguide PC program'."\n".'Check the program is running (you must start it BEFORE running this grabber)'."\n".'If it is running then check your config parameters: IP='.$conf->{'digiguide_ip'}->[0].' Port='.$conf->{'digiguide_port'}.' Password=(hidden)'."\n";
				exit 1;
			}
		}

		
		# convert the channels array into a hash for "if element in array" testing
		#  (only needed by 'multi' really)
		my %chan_hash = map { $_, 1 } @{$conf->{channel}};
			
		# Fetch single channel-days or go for the multi-grid?
		#
		if ($conf->{'method'}[0] ne 'multi') {

			# Get listings for each day for each channel
			#
			foreach my $channel_id (@{$conf->{channel}}) {
			
				my $baseurl = $ROOT_URL.'viewsinglechannellist';
				
				# The user may have the guide running from 06:00-06:00 but we can't tell,
				#		so we need to get the previous day as well just for any programmes after midnight
				#
				for (my $i=($opt->{offset} -1); $i < ($opt->{offset} + $opt->{days}); $i++) {
					my $theday = DateTime->today->add (days => $i)->set_time_zone('Europe/London')->set(hour => 0, minute => 0, second => 0);
					my $dt = time + ($i * 86400);
				
					# Construct the listings url
					my $url = $baseurl . '?ch=' . $channel_id . '&dt=' . $dt;
					debug "Fetching: $url";
					
					# Fetch the page
					my $t_tree = XMLTV::Get_nice::get_nice_tree($url, '', $src_encoding);
					# print STDERR Dumper($XMLTV::Get_nice::response); 
					# $tree->dump; exit;			
			
					# Parse the schedule and add the programmes to the programme hash
					if ($t_tree) {
						extract_schedule($i, $theday, $channel_id, $t_tree, \%chan_hash);
					} else {
						# tree conversion failed
						warning 'Could not parse the page';
					}

					$bar->update if defined $bar;
					
				}	
				
			}
			
			
		######
		} else {

			# Get listings for all channels, filtering out the ones we want
			#
			my $localbar;	
			
			my $baseurl = $ROOT_URL.'viewmultichannelgrid';

			for (my $i=$opt->{offset}; $i < ($opt->{offset} + $opt->{days}); $i++) {
							
				# Set the start of fetch time to midnight on the chosen day
				#
				my $dt = DateTime->today->add (days => $i)->set_time_zone('Europe/London')->set(hour => 0, minute => 0, second => 0)->epoch();
				
				my $hours = $opt->{'days'} * 24;		# num hrs to fetch
							
				my ($startch, $numchs) = (0, 10);		# channel "num" to start at and num channels to get at a time
				
				while (1) {
				
					# Construct the listings url
					my $url = $baseurl . '?dt=' . $dt . '&htd=' . $hours . '&chi=' . $startch .'&noc=' . $numchs;
					debug "Fetching: $url";
					
					# Fetch the page
					my $t_tree = XMLTV::Get_nice::get_nice_tree($url, '', $src_encoding);
					# print STDERR Dumper($XMLTV::Get_nice::response); 
					# $tree->dump; exit;
					
					my $is_404;
					
					# Parse the schedule and add the programmes to the programme hash
					if ($t_tree) {
						$is_404 = extract_schedule(-9999, '', '', $t_tree, \%chan_hash);
					} else {
						# tree conversion failed
						warning 'Could not parse the page';
					}
					
					# if no channels returned then assume we have seen them all
					last if $is_404;
					# else get the next batch of channels grid
					$startch += $numchs;
					
					$bar->update() if defined $bar;
					$localbar->update() if defined $localbar;
					
				}

				
				# now we know how many channels fill the grid so we can produce an accurate bar
				undef $bar if defined $bar;		# kill the current bar and...
				if (!defined $localbar) {			# ...start a new one
					my $barcount = $startch / $numchs;
					$localbar = new XMLTV::ProgressBar({
							name => "Fetching listings",
							count => $barcount * $opt->{days},
							ETA => 'linear',
					}) unless ($opt->{quiet} || $opt->{debug});		
					$localbar->update($barcount) if defined $localbar;		# we've already done 1 day's fetch
				}

			}
			
			$localbar->finish() && undef $localbar if defined $localbar;
			
			
		######
		}
}

sub extract_schedule {
		#  Extract the schedule for this channel-day
		
		my ( $i, $theday, $channel_id, $t_tree, $chan_hash ) = @_;
		
		my ( $channel_num, $channel_xmltv, $channel_name );
		
		# Scrub the page
		if ($t_tree) {
				
			my @t_tables = $t_tree->look_down('_tag' => 'table', 'id' => 'programme-multilist')->look_down('_tag' => 'table', 'id' => 'programme-list');
			
			if (@t_tables) {
				foreach my $t_table (@t_tables) {

					my @t_shows = $t_table->look_down('_tag' => 'tbody')->look_down('_tag' => 'tr');
					
					if (@t_shows) {
						foreach my $t_show (@t_shows) {
							#		$show->dump;
							
							# for 'multi' (i.e. grid) grabs we need to ignore channels we don't want
							next if !$chan_hash->{ $t_show->look_down('_tag' => 'td', 'class' => 'programme-channelid')->as_text } ;
			
			
							# are we processing yesterday's schedule? (see above)
							#   - we could just grab the data anyway and let xmltv sort it out via the %w_args 
							#     but let's try and be a bit cleverer than that
							#
							if ($i == ($opt->{offset} -1)) {
								my $t_start = $t_show->look_down('_tag' => 'td', 'class' => 'programme-starttime');
								my ($h, $i, $a) = $t_start->as_text =~ /(\d*):(\d*)(am|pm)?/;
								if ($h < 6) {
									debug 'Processing '.$t_start->as_text;
									# continue processing of pre-6am programme
								} else {
									debug 'Skipping '.$t_start->as_text;
									next;
								}
								$t_start = $h = $i = $a = undef;
							}
							
							
				
							# Channel name and number
							#		<span id="channel-name">Film4</span> (<span id="channel-epg">315</span>)
							#
							$channel_id 	= $t_show->look_down('_tag' => 'td', 'class' => 'programme-channelid')->as_text;
							$channel_num 	= $t_show->look_down('_tag' => 'td', 'class' => 'programme-channelassignment')->as_text;
							$channel_name = $t_show->look_down('_tag' => 'td', 'class' => 'programme-channelname')->as_text;
							$channel_num  = 'ID_'.$channel_id  if !defined $channel_num;		# if there is no epg number for this channel		
							$channel_xmltv = make_channel_id($channel_id, $channel_num, $conf);		 # RFC2838 compliant id
							
							# Add this channel the global channels hash
							$channels->{$channel_id} = { 'id'=> $channel_xmltv , 'display-name' => [[$channel_name, 'en']]  };
						
						
						
							# clear our working data
							my %prog = ();
							
							#
							$prog{'channel'} = $channel_num;
							
							
							# Time
							#		<td class="programme-date">18/01/2014</td>
							#		<td class="programme-starttime-secs">1390042800</td>
							#		<td class="programme-starttime">11:00</td>
							#		<td class="programme-endtime">13:00</td>
							#		<td class="programme-duration">2 hours</td>
							#
							$prog{'start'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-starttime-secs')->as_text;
				
							# best to avoid parsing textual content for the duration (e.g. "1 hour and 30 minutes"); so we'll subtract the hh:mm times
							# *but* I don't know how Digiguide will display times at GMT/BST switchover - for now I'll assume they added "BST" or "GMT"
							#
							my $_starttime = $t_show->look_down('_tag' => 'td', 'class' => 'programme-starttime')->as_text;
							my ($h1, $i1, $d1) = $_starttime =~ /(\d*):(\d*)\s?(GMT|BST)?/;
							my $_endtime = $t_show->look_down('_tag' => 'td', 'class' => 'programme-endtime')->as_text;
							my ($h2, $i2, $d2) = $_endtime =~ /(\d*):(\d*)\s?(GMT|BST)?/;
							my $_durationmins = ( (($h2*60)+$i2) - (($h1*60)+$i1) ); $_durationmins += 1440  if $_durationmins < 0;
							$d1 = '' if !defined $d1;  $d2 = '' if !defined $d2;
							$_durationmins += 3600  if $d1 eq 'BST' && $d2 eq 'GMT';
							$_durationmins -= 3600  if $d1 eq 'GMT' && $d2 eq 'BST';
							$prog{'stop'} = $prog{'start'} + ($_durationmins * 60);
							#
							# we *could* parse the textual duration:
							my $_duration = $t_show->look_down('_tag' => 'td', 'class' => 'programme-duration')->as_text;
							my ($h) = $_duration =~ /(\d*) hour/;
							my ($m) = $_duration =~ /(\d*) minute/;
							my $_durationmins_t = ($h ? $h*60 : 0) + ($m ? $m : 0);
							warning 'Duration mismatch: '.$_durationmins.' : '.$_durationmins_t  if $_durationmins != $_durationmins_t;
							
							
							# Title
							#		<td class="programme-name">One Million Years B.C.</td>
							#
							$prog{'title'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-name')->as_text;
								
							debug 'Prog '.$_starttime.' '.$prog{'title'};
							
							# Episode Title
							#		<td class="programme-episode-name"></td>
							#
							$prog{'episodetitle'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-episode-name')->as_text;
								
							# Description
							#		<td class="programme-description-only">Director Don Chaffey's reunion with special effects supremo the late Ray Harryhausen created a 
							#		prehistoric world, rife with earthquakes and dinosaurs - and, of course, Raquel Welch in her famous fur bikini. It's a world that man doesn't quite 
							#		yet rule. An inhospitable landscape is populated by two tribes: the Rock People and the Shell People. When, following a fight with his father, Tumak 
							#		is banished from the Rock People, he wanders as an outcast, battling roving dinosaurs and other hardships before teaming up with Loana to head off 
							#		into the sunset and face new hazards.</td>
							#
							$prog{'desc'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-description-only')->as_text;
							
							# Ser/Ep details
							#		<td class="programme-series-number"></td>
							#		<td class="programme-episode-number"></td>
							#
							$prog{'seriesno'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-series-number')->as_text;	
							$prog{'epno'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-episode-number')->as_text;	
							#$prog{'totaleps'};
								
							# Categories
							#		<td class="programme-categoryname">Film</td>
							#					
							# I think they only ever have 1 but just in case:			
							my $_categories = $t_show->look_down('_tag' => 'td', 'class' => 'programme-categoryname')->as_text;
							foreach ( split(',', $_categories) ) {
								$prog{'genres'}->{ $_ } = 1; 
							}
							
							# Cast & Crew
							#		<td class="programme-person">
							#			<div class="programme-person-list-director">Don Chaffey</div>
							#			<div class="programme-person-list-starring">Raquel Welch~John Richardson~Percy Herbert~Robert Brown~Martine Beswick~Jean Wladon</div>
							#			<div class="programme-person-list-guest-starring"></div>
							#			<div class="programme-person-list-writer"></div>
							#			<div class="programme-person-list-producer"></div>
							#			<div class="programme-person-list-executive-producer"></div>
							#		</td>
							#	
							# <!ELEMENT credits (director*, actor*, writer*, adapter*, producer*, composer*, editor*, presenter*, commentator*, guest* )>
							#
							my $_people = $t_show->look_down('_tag' => 'td', 'class' => 'programme-person');	
							
							foreach my $role ( qw/director starring guest-starring writer producer executive-producer/ ) {
								my @_persons = split(/~/, ( $_people->look_down('_tag' => 'div', 'class' => 'programme-person-list-'.$role)->as_text ) );	
								SWITCH: {
									$role eq 'director' 					&& do { foreach (@_persons) { push @{$prog{'directors'}}, $_ }; last SWITCH; };
									$role eq 'starring' 					&& do { foreach (@_persons) { push @{$prog{'actors'}}, $_ }; 		last SWITCH; };
									$role eq 'guest-starring' 		&& do { foreach (@_persons) { push @{$prog{'actors'}}, $_ }; 		last SWITCH; };
									$role eq 'writer' 						&& do { foreach (@_persons) { push @{$prog{'writers'}}, $_ }; 	last SWITCH; };
									$role eq 'producer' 					&& do { foreach (@_persons) { push @{$prog{'producers'}}, $_ }; last SWITCH; };
									$role eq 'executive-producer' && do { last SWITCH; };
								}
							}

							
							# Other programme data which DG lump all together
							#		<td class="programme-qualifiers">Subtitles, 1966, PG, 3 Star</td>
							# 		(Stereo, Repeat, Widescreen, Subtitles, Audio Described, 2010, 4 Star)
							#			(Premiere, Widescreen, Subtitles, 1978, PG, 3 Star)
							#			(Repeat, Widescreen, Subtitles, Dolby Digital 5.1, Audio Described)
							#			(Black and White, Subtitles, Audio Described, 1959, U, 3 Star)
							#			(Subtitles, Subtitled, In French with English Subtitles, Premiere, Widescreen, 2010, 15, 3 Star)
							#			(Stereo, Repeat, Widescreen, Subtitles, Signed, Audio Described)
							#			(Editor's Choice, New, Stereo, Widescreen, High Definition, Subtitles, Audio Described, 2012, 5 Star)
							#			(Repeat, Part 11 of 13, Subtitles, 4 Star)
							#
							my $_data = $t_show->look_down('_tag' => 'td', 'class' => 'programme-qualifiers')->as_text;	
											
							# $prog{'film'}
							# $prog{'image'}
							( $prog{'year'} ) = $_data =~ /((?:19|20)\d\d)/;				
							$prog{'subtitles'} 				= ( $_data =~ /Subtitles/ ? 1 : 0 );
							$prog{'deaf_signed'} 			= ( $_data =~ /Signed/ ? 1 : 0 );
							$prog{'audio_signed'} 		= ( $_data =~ /Audio Described/ ? 1 : 0 );
							$prog{'premiere'} 				= ( $_data =~ /Premiere/ ? 1 : 0 );
							$prog{'repeat'} 					= ( $_data =~ /Repeat/ ? 1 : 0 );
							# $prog{'new_series'}
							$prog{'new_episode'}			= ( $_data =~ /New/ ? 1 : 0 );
							# 	we'll assume any 4 digit epg numbers are radio stations (note not everything in DG has an epg number)
							$prog{'media'} 						= ( $channel_num =~ /^\d{1,3}$/ ? 'video' : ( $channel_num =~ /^\d{4}$/ ? 'audio' : '' ) );
							$prog{'black_and_white'}	= ( $_data =~ /Black and White/ ? 1 : 0 );
							$prog{'widescreen'} 			= ( $_data =~ /Widescreen/ ? 1 : 0 );
							$prog{'high_def'} 				= ( $_data =~ /High Definition/ ? 1 : 0 );
							$prog{'surround'} 				= ( $_data =~ /Dolby Digital 5.1/ ? 1 : 0 );
							($prog{'certificate'})		= $_data =~ /(E|U|PG|12|12A|15|18|R18)(,|$)/;
							$prog{'certificate_code'}	= ( $prog{'certificate'} ? 'BBFC' : '' );
							($prog{'star_rating'})		= $_data =~ /(\d) Star/;
					
					
							# Sometimes the episode details are in the other prog data rather than in the proper fields.
							# I think when they do this it is always series 1, but we shouldn't set the serno since it will mess with 2-part 
							#		films, e.g. "Bombers of the Second World War" = "(Part 2, PG)"
							#
							my ($ep, $of) = $_data =~ /Part (\d+) of (\d+)/;
							$prog{'epno'} = $ep 	if $ep && !$prog{'epno'};
							$prog{'totaleps'} = $of 	if $of && !$prog{'totaleps'};
							
							
							# DigiGuide's programme identifier
							#		<td class="programme-programmeid">174806</td>
							#
							$prog{'dgid'} = $t_show->look_down('_tag' => 'td', 'class' => 'programme-programmeid')->as_text;	
							
							
							
							# Done with data collection
							#
							# Check this isn't a duplicate.  (DG PC starts with whatever is currently showing (e.g. if film spans midnight then 
							#		it will be fetched twice; as last prog on day '1' and also as first prog on day '2' )
							#
							if ($progtimes{ $prog{'start'} } && $progtimes{ $prog{'start'} } eq $prog{'title'} ) {
								debug 'Skipping duplicate';
								next;
							}
							$progtimes{ $prog{'start'} } = $prog{'title'};
							
							
							# Convert the broadcast/programme to XMLTV format
							# debug Dumper \%prog;
							add_programme_to_xml($channel_id, $channel_xmltv, $channel_name, \%prog);

						}	# end t_show

					} else {
						# no schedule found
						debug 'No schedule found';
						warning 'No schedule found';
					}
					
					undef @t_shows;
			
			
				} # end t_table
			} else {
				# no channels-schedule found 
				return 1;
			}
		
		}  # end t_tree

		return 0;
}
		
sub add_programme_to_xml {
		# Add a programme to the XML hash
		
		my ( $channel_id, $channel_xmltv, $channel_name, $prog ) = @_;
		my %prog = %$prog;
		my %xmlprog = ();		
		
		#debug Dumper(\%prog);
		
		$xmlprog{'channel'} 				= $channel_xmltv;
		$xmlprog{'start'} 					= DateTime->from_epoch( epoch => $prog{'start'} )->set_time_zone('Europe/London')->strftime("%Y%m%d%H%M%S %z");
		$xmlprog{'stop'} 						= DateTime->from_epoch( epoch => $prog{'stop'} )->set_time_zone('Europe/London')->strftime("%Y%m%d%H%M%S %z");

		$xmlprog{'title'} 					= [[ codify( $prog{'title'} ), 'en' ]];
		$xmlprog{'sub-title'} 			= [[ codify( $prog{'episodetitle'} ), 'en' ]] 		if ($prog{'episodetitle'});
		$xmlprog{'desc'} 						= [[ codify( $prog{'desc'} ), 'en' ]] 						if ($prog{'desc'});
		
		if ( $prog{'seriesno'} || $prog{'epno'} ) {
			my $showepnum = make_ns_epnum($prog{'seriesno'}, $prog{'epno'}, $prog{'totaleps'});
			$xmlprog{'episode-num'} 	= [[ $showepnum, 'xmltv_ns' ]]									if ($showepnum && $showepnum ne '..');
		}
	
		foreach my $role ( qw/director actor writer adapter producer composer editor presenter commentator guest/ ) {
			if ($prog{($role.'s')} && scalar @{$prog{($role.'s')}} > 0) {
				foreach my $showperson ( @{$prog{$role.'s'}}) {
					if (ref($showperson) eq 'ARRAY') { 
						push @{$xmlprog{'credits'}{$role}}, [ codify( @{$showperson}[0] ), codify( @{$showperson}[1] ) ];
					} else {
						push @{$xmlprog{'credits'}{$role}}, codify( $showperson );
					}
				}
			}
		}
		
		$xmlprog{'date'} = $prog{'year'} 														if $prog{'year'};
		push @{$xmlprog{'icon'}}, {'src' => $prog{'image'}} 				if $prog{'image'};

		# add 'Film' genre if it's a film
		if ($prog{'film'}) {
			$prog{'genres'}->{ 'Film' } = 1; 
		}
		if (scalar (keys %{$prog{'genres'}}) > 0) {		
			while (my ($key, $value) = each %{$prog{'genres'}}) {
				push @{$xmlprog{category}}, [ codify( $key ), 'en' ];
			}
		}
			
		push @{$xmlprog{'subtitles'}}, {'type' => 'teletext'} 			if $prog{'subtitles'};
		push @{$xmlprog{'subtitles'}}, {'type' => 'deaf-signed'} 		if $prog{'deaf_signed'};
		push @{$xmlprog{'subtitles'}}, {'type' => 'deaf-signed'} 		if $prog{'audio_signed'};
		$xmlprog{'premiere'} = []																		if $prog{'premiere'};
		$xmlprog{'previously-shown'} = {} 													if $prog{'repeat'};
		$xmlprog{'new'} = {} 																				if $prog{'new_series'} || $prog{'new_episode'};
		$xmlprog{'video'}->{'present'} = 1 													if $prog{'media'} && $prog{'media'} eq 'video';
		$xmlprog{'video'}->{'present'} = 0 													if $prog{'media'} && $prog{'media'} eq 'audio';
		$xmlprog{'video'}->{'colour'} = 0 													if $prog{'black_and_white'};
		$xmlprog{'video'}->{'aspect'} = '16:9' 											if $prog{'widescreen'};
		$xmlprog{'video'}->{'quality'} = 'HDTV' 										if $prog{'high_def'};
		$xmlprog{'audio'}->{'stereo'} = 'surround' 									if $prog{'surround'};
		$xmlprog{'rating'} = [[ $prog{'certificate'}, $prog{'certificate_code'} ]]	if $prog{'certificate'};
		$xmlprog{'star-rating'} =  [ $prog{'star_rating'} . '/5' ]	if $prog{'star_rating'};

		
		
		# The above code should be pretty generic to all grabbers,
		# the following is specific to this one grabber
		#
		# Output an additional 'episode_num' with the DigiGuide programme id.  
		# These can be used to match existing objects in your EPG (& so avoid having to do title matching etc.).
		# However some poorly written EPG processors may not allow for multiple 'episode_num' tags, so we'll let the user
		# disable this additional tag.
		if ( (not defined( $conf->{writeids} )) || ( not $conf->{writeids}->[0] =~ /no?/i ) ) {
			my $showids = $prog{'dgid'};
			push @{$xmlprog{'episode-num'}}, [ $showids, 'digiguideid' ]	if ($showids && $showids ne '');
		}
	
	
	
		#print Dumper \%xmlprog;
		push(@{$programmes}, \%xmlprog);
		
		return;
}		
	
		
# ####################################################################
# # THE VEG #############################################################
# ------------------------------------------------------------------------------------------------------------------------------------- #

sub log_in ( $$ ) {
		# We need to log-in to the PC program. 
		# Web server access uses a SID in the URL. So let's get that SID...
		
		my ($conf, $opt) = @_;

		debug 'Logging-in to Digiguide for Windows';
		
		$ROOT_URL  = 'http://'.$conf->{'digiguide_ip'}->[0].':'.$conf->{'digiguide_port'}->[0].'/skin-xmltv/';

		# prevent get_nice from dieing on error
		$XMLTV::Get_nice::FailOnError = 0;
		
		# check server is alive and the skin is installed
		my $url = $ROOT_URL.'login';
		my $content = get_nice($url);
		
		my $httpcode = $XMLTV::Get_nice::Response->code;
		#debug $httpcode;
		if ($httpcode == 404 || $httpcode == 500) {
			print STDERR 'Cannot find DigiGuide Web Application. Make sure:'."\n"
									.	'1) You have started the DigiGuide Windows Program'."\n"
									.	'2) You have entered your web/IP address correctly'."\n"
									.	'3) You have entered the correct port number'."\n"
									.	'4) You have installed the xmltv skin'."\n"."\n";
			exit 1;
		}
		
		if ($content eq "<h1>Skin 'xmltv' is missing</h1>") {
			print STDERR 'Cannot find the xmltv skin. Make sure you have installed it into the correct program directory.'."\n";
			exit 1;
		}
		
		
		# login to the program's http server
		$url = $ROOT_URL.'dologin?password='.$conf->{'digiguide_password'}->[0];

		# get the page but don't follow the redirect
		$XMLTV::Get_nice::ua->requests_redirectable( [] );	
		get_nice($url);
		#print STDERR Dumper($XMLTV::Get_nice::Response); 

		# inspect the Location header on the 302 and extract the SID
		my $location = $XMLTV::Get_nice::Response->header( 'Location' );
		debug 'Location:'.$location; 	# e.g. '/skin-webdefault/sid-E0CD183D-475A-48EA-9AB2-113205C3E5BA/index'
		
		(my $sid) = $location =~ /\/skin-xmltv\/(sid-.*)\/index/;
		debug 'SID='.$sid if $sid; 
		
		if (!defined $sid) { print STDERR 'Runtime error - Cannot find SID'."\n"; exit 1; }
		$dgsid = $sid;
		
		$ROOT_URL = $ROOT_URL.$sid.'/';
		
		# reset get_nice
		$XMLTV::Get_nice::FailOnError = 1;
}

sub list_channels ( $$ ) {
		# List all available channels (in xmltv.dtd format).
		
		# ParseOptions() hasn't set the global $conf or $opt yet, but we need this during log_in etc 
		#		so rather than passing to every sub that might need them, we'll fudge the globals
		($conf, $opt) = @_;
		
		my @channels = fetch_channels ($conf, $opt);
		
		# We must return an xml-string (c.f. Options.pm), E.g.:
		#  	<channel id="4058">
    #			<display-name lang="en">BBC 1 South (101)</display-name>
		#		</channel>
		#		<channel id="4230">
    #			<display-name lang="en">Film4 (315)</display-name>
		#		</channel>
		#
		# Map the list of channels to a hash XMLTV::Writer will understand
		my $channels_conf = {};
		foreach my $c (@channels) {
			my %channel = %$c;
	
			if ($opt->{'configure'}) { 
				$channels_conf->{$channel{'num'}} = {
					'id' => $channel{'id'},
					'display-name' => [[ $channel{'title'}, 'en' ]],
				};
			} else {
				$channels_conf->{$channel{'num'}} = {
					'id' => make_channel_id($channel{'id'},$channel{'num'},$conf),		 # RFC2838 compliant id
					'display-name' => [[ $channel{'title'}, 'en' ]],
				};
			}
			$channels_conf->{$channel{'num'}}->{'icon'} = [ {'src' => $channel{'image'} } ]   if $channel{'image'};
			$channels_conf->{$channel{'num'}}->{'url'} = [ $channel{'url'} ]  if $channel{'url'};
		}
		#
		# Let XMLTV::Writer format the results as xml. 
		my $result;
		my $writer = new XMLTV::Writer(OUTPUT => \$result, encoding => 'UTF-8');
		$writer->start({'generator-info-name' => $generator_info_name});
		$writer->write_channels($channels_conf);
		$writer->end();
		return $result;
}

sub fetch_channels ( $$ ) {
		# Fetch available channels
		
		my ($conf, $opt) = @_;
		
		log_in($conf, $opt);
			
		# Fetch channels via a dummy call 
		#  	http://localhost:2402/skin-xmltv/sid-6CCDF18A-D24E-48CC-9BC5-AA936C9633C8/viewsinglechannellist?ch=0&dt=1390035027
		#
		my $channel_list_url = $ROOT_URL.'viewsinglechannellist?ch=0&dt='.time;

		my @channels = ();
		
		my $bar = new XMLTV::ProgressBar({
				name => "Fetching channels",
				count => 1
		}) unless ($opt->{quiet} || $opt->{debug});

		# Get the page containing the list of channels 
		my $tree = XMLTV::Get_nice::get_nice_tree($channel_list_url);
		#		$tree->dump;
		my $_channels = $tree->look_down('_tag' => 'select', 'name' => 'ch');
		my @_channels = $_channels->look_down('_tag' => 'option');

		$bar->update() && $bar->finish && undef $bar if defined $bar;

		$bar = new XMLTV::ProgressBar({
				name => "Parsing result",
				count => scalar @_channels
		}) unless ($opt->{quiet} || $opt->{debug});

		# 
		foreach my $c (@_channels) {
			if ($c->as_text) {
				next if $c->attr('value') eq '';
				
				my %ch = ();
				$ch{'id'} 		= $c->attr('value');
				($ch{'num'}) 	= $c->as_text =~ /.*\((\d*)\)$/;							# e.g. 'Film4 (315)'
				$ch{'num'}		= 'ID_'.$ch{'id'}  if !defined $ch{'num'};		# if there is no epg number for this channel
				($ch{'title'})= $c->as_text =~ /(.*?)\s?(\(\d*\))?$/;
				$ch{'image'} 	= '';
				$ch{'url'} 		= '';  # 'viewsinglechannellist?ch=' . $c->attr('value');	<-- no point in keeping this since the log-in expires		
				push @channels, \%ch;

			}

			$bar->update() if defined $bar;
		}

		$bar->update() && $bar->finish && undef $bar if defined $bar;
		
		#print Dumper(@channels);exit;
		return @channels;
}

sub config_stage ( $$ ) {
		my ( $stage, $conf ) = @_;				# note that $conf is mostly empty at this stage of course

		if ( $stage eq 'start' ) {
			print "\nTo use this grabber you must have already installed a working copy of 'Digiguide for Windows' (version 8.1 or newer). \n"
					. "You must have enabled its Web Service (go to Tools menu -> Customise -> Web Service). \n"
					. "You must also have installed the xmltv 'skin' supplied with this grabber (see 'tv_grab_uk_dgpc --info' ). \n"
					. "\n";
		}
		
		my $result;
		my $writer = new XMLTV::Configure::Writer( OUTPUT => \$result, encoding => 'UTF-8' );
		$writer->start( { grabber => $GRABBER_NAME } );
			
		# ------------------------------------------------------------------ #
		if ( ($stage eq 'start') ||
			 ($stage eq 'select-ip') ) {
			 
        $writer->write_string( {
						id => 'digiguide_ip', 
						title => [ [ 'Enter web or IP address of your DigiGuide program', 'en' ] ],
						description => [ [ $GRABBER_NAME.' connects to your personal DigiGuide for Windows program', 'en' ] ],
						default => 'localhost',
        } );
				
        $writer->end('select-port');
				
    }	
		# ------------------------------------------------------------------ #
		elsif ($stage eq 'select-port') {
			 
        $writer->write_string( {
						id => 'digiguide_port', 
						title => [ [ 'Enter port to connect to on your DigiGuide program', 'en' ] ],
						description => [ [ 'Port number you configured for access (Tools -> Customise -> Web Service)', 'en' ] ],
						default => '2402',
        } );
				
        $writer->end('select-password');
				
    }	
		# ------------------------------------------------------------------ #
		elsif ($stage eq 'select-password') {
			 
        $writer->write_string( {
						id => 'digiguide_password', 
						title => [ [ 'Enter your password to connect to your DigiGuide program', 'en' ] ],
						description => [ [ 'Password you configured for access (Tools -> Customise -> Web Service)', 'en' ] ],
						default => '',
        } );
				
				$writer->end('select-option-method');
				
		}
		# ------------------------------------------------------------------ #
		elsif ($stage eq 'select-option-method') {
			 
        $writer->write_string( {
						id => 'method', 
						title => [ [ 'Select grabber method (single/multi)', 'en' ] ],
						description => [ [ 'Grabber can either fetch channels one at a time or use DG\'s grid to get multiple channels at once. (Hint: if fetching lots of channels then multi will be quicker)', 'en' ] ],
						default => 'multi',
        } );
				
				$writer->end('select-option-rfc2838');
				
		}
		# ------------------------------------------------------------------ #
		elsif ($stage eq 'select-option-rfc2838') {
			 
        $writer->write_string( {
						id => 'rfc2838_epg', 
						title => [ [ 'Use EPG number in channel id? (yes/no)', 'en' ] ],
						description => [ [ $GRABBER_NAME.' normally outputs the internal channel id, but you can use the EPG number instead. (Note: not all your channels will have an EPG number and make sure none of them overlap!)', 'en' ] ],
						default => 'no',
        } );
				
        $writer->end('select-option-dgid');
				
    }	
		# ------------------------------------------------------------------ #
		elsif ($stage eq 'select-option-dgid') {
			 
        $writer->write_string( {
						id => 'writeids', 
						title => [ [ 'Output DigiGuide programme ids? (yes/no)', 'en' ] ],
						description => [ [ $GRABBER_NAME.' normally outputs an episode-num tag with programme ids from the DigiGuide server.', 'en' ] ],
						default => 'yes',
        } );
				
        $writer->end('select-channels');
				
    }	
		# ------------------------------------------------------------------ #
    else {
        die "Unknown stage $stage";
    }

		# ------------------------------------------------------------------ #
		return $result;
}

sub config_check {
		if (not defined( $conf->{digiguide_ip} )) {
				print STDERR "Location for Digiguide PC program not defined in config file " . 
										 $opt->{'config-file'} . "\n" .
										 "Please run the grabber with --configure.\n";
				exit 1;
		}
		if (not defined( $conf->{digiguide_port} )) {
				print STDERR "Server port for Digiguide PC program not defined in config file " . 
										 $opt->{'config-file'} . "\n" .
										 "Please run the grabber with --configure.\n";
				exit 1;
		}
		if (not defined( $conf->{digiguide_password} )) {
				print STDERR "Password for Digiguide PC program not defined in config file " . 
										 $opt->{'config-file'} . "\n" .
										 "Please run the grabber with --configure.\n";
				exit 1;
		}

		if (not defined( $conf->{'channel'} )) {
				print STDERR "No channels selected in config file " .
										 $opt->{'config-file'} . "\n" .
										 "Please run the grabber with --configure.\n";
				exit 1;
		}
}


# ####################################################################
# # THE GRAVY ###########################################################
# ------------------------------------------------------------------------------------------------------------------------------------- #

sub make_channel_id ( $$$ ) {
		# Create a 'channel id' for output in the XML
		#		If user selected rfc2838_epg option then we output the 'epg id', else we output the digiguide 'internal id'
		#
		my ($digiguide_id, $epg_id, $conf) = @_;
		
		if ( (not defined( $conf->{'rfc2838_epg'} )) || ( not $conf->{'rfc2838_epg'}->[0] =~ /ye?s?/i ) ) {	
			return $digiguide_id.'.pc.digiguide.tv';
		} else {
			return ($epg_id eq '' ? 'ID_'.$digiguide_id : $epg_id).'.pc.digiguide.tv';
		}
}

sub make_ns_epnum {
		# Convert an episode number to its xmltv_ns compatible - i.e. reset the base to zero
		# Input = series number, episode number, total episodes,  part number, total parts,
		#  e.g. "1, 3, 6, 2, 4" >> "0.2/6.1/4",    "3, 4" >> "2.3."
		#
		my ($s, $e, $e_of, $p, $p_of) = @_;
		#	debug Dumper(@_);

		# "Part x of x" may contain integers or words (e.g. "Part 1 of 2", or "Part one")
		$p = text_to_num($p) if defined $p;
		$p_of = text_to_num($p_of) if defined $p_of;
		
		# re-base the series/episode/part numbers
		$s-- if (defined $s && ($s =~ /^\d+$/) && $s > 0);
		$e-- if (defined $e && ($e =~ /^\d+$/) && $e > 0);
		$p-- if (defined $p && ($p =~ /^\d+$/) && $p > 0);
		
		# make the xmltv_ns compliant episode-num
		my $episode_ns = '';
		$episode_ns .= $s if defined $s;
		$episode_ns .= '.';
		$episode_ns .= $e if defined $e;
		$episode_ns .= '/'.$e_of if defined $e_of;
		$episode_ns .= '.';
		$episode_ns .= $p if defined $p;
		$episode_ns .= '/'.$p_of if defined $p_of;
		
		#debug "--$episode_ns--";
		return $episode_ns;
}
	
sub text_to_num {
		# Convert a word number to int e.g. 'one' >> '1'
		#
		my ($text) = @_;
		if ($text !~ /^[+-]?\d+$/) {	# standard test for an int
			my %nums = (one => 1, two => 2, three => 3, four => 4, five => 5, six => 6, seven => 7, eight => 8, nine => 9);
			return $nums{$text} if exists $nums{$text};
		}
		return $text
}

sub get_default_dir {
    my $winhome = $ENV{HOMEDRIVE} . $ENV{HOMEPATH} 
			if defined( $ENV{HOMEDRIVE} ) 
					and defined( $ENV{HOMEPATH} ); 
    
    my $home = $ENV{HOME} || $winhome || ".";
    return $home;
}

sub get_default_cachedir {
    return get_default_dir() . "/.xmltv/cache";
}

sub init_cachedir {
    my( $path ) = @_;
    if( not -d $path ) {
        mkpath( $path ) or die "Failed to create cache-directory $path: $@";
    }
}

sub codify ( $ ) {
		# Encode the text as UTF-8
		return encode( 'UTF-8', $_[0] );
}
		
sub trim {
	# Remove leading & trailing spaces
	$_[0] =~ s/^\s+|\s+$//g;       
}

sub debug ( $$ ) {
    my( $message, $nonewline ) = @_;
    print STDERR $message if $opt->{debug};
    print STDERR "\n" if $opt->{debug} && (!defined $nonewline || $nonewline != 1);
}

sub warning ( $ ) {
    my( $message ) = @_;
    print STDERR $message . "\n";
    $warnings++;
}


# #############################################################################

__END__

=pod

=head1 NAME

tv_grab_uk_dgpc - Grab TV and radio programme listings for UK from 
"Digiguide for Windows" PC program.

=head1 DESCRIPTION

Output TV listings in XMLTV format for most channels available in UK.
The data come from L<http://digiguide.tv/>

First you must run B<tv_grab_uk_dgpc --configure> to choose which channels
you want to receive.

Then running B<tv_grab_uk_dgpc> with no arguments will get a listings in XML
format for the channels you chose for available days including today.

=head1 OPTIONS

Please see B<tv_grab_uk_dgpc  --help>

=head1 INSTALLATION

1.
To use this grabber you must have already installed a working copy of 
"Digiguide for Windows" (version 8.1 or newer). L<http://digiguide.tv/products/windows.asp>
This will require an annual subscription to digiguide.tv epg service.

2.
Select the channels you wish to view: go to "Tools" : "Add/Remove Channels" in
your "Digiguide for Windows" program.

3.
Then you must enable "Digiguide for Windows" I<Web Service> via "Tools" menu : 
"Customise" : "Web Service". You need to close and re-open DigiGuide for these 
changes to take effect.  L<http://helpdesk.digiguide.tv/solution.asp?s=164&sl=174>

(With the default settings you should be able to get to your browser version using the 
following URL: L<http://localhost:2402/> )

4.
You must put the "xmltv" web skin into your Digiguide program"s directory. 
E.g. something like
"F<C:\Program Files\DigiGuide TV Guide\schemes\server skins\>". 
Move the file F<xmltv.dgscheme-web> into this directory. 

(If you can"t find that directory then try searching for "web.dgscheme-web" - that will 
be the directory you want.)

5.
Grabber configuration consists of the usual:  
B<tv_grab_uk_dgpc --configure>

B<Note:> you will only be able to grab channels which you have currently 
selected within "Digiguide for Windows".
		

=head1 ERROR HANDLING

If the grabber fails to download data for some channel on a specific day, 
it will print an errormessage to STDERR and then continue with the other
channels and days. The grabber will exit with a status code of 1 to indicate 
that the data is incomplete. 

=head1 ENVIRONMENT VARIABLES

The environment variable HOME can be set to change where configuration
files are stored. All configuration is stored in $HOME/.xmltv/. On Windows,
it might be necessary to set HOME to a path without spaces in it.

=head1 SUPPORTED CHANNELS

For information on supported channels go to "Tools" : "Add/remove Channels" in
your "Digiguide for Windows" program.

=head1 FAQs

1.  --list-channels is blank

Make sure you have selected some channels within "Digiguide for Windows".
(Go to "Tools" : "Add/remove Channels")

2.  There are gaps in the listings!

If you have hidden any programmes or categories within "Digiguide for Windows"
they will not appear in the XML file. If you think about it you will see 
this is a feature not a fault - you have said you are not interested in a 
particular programme so why would you want to carry it in to your PVR?  
This is actually a useful way of filtering stuff you don"t want to see out 
of your PVR guide!
(See the "Digiguide for Windows" program for a description of how to use 
their "hide" markers.)
    
 
=head1 DISCLAIMER

The Digiguide license for these data does not allow non-personal use. 
Nor does it allow you to "systematically extract listings schedules 
data or information from the Product for any use and for any reason".

You must consider whether your intended use of this grabber falls
within the terms of this Software License. (See 
L<http://digiguide.tv/general/terms_software.asp> )

By using this grabber you aver you are using the listings data for your own 
personal use only and you absolve the author(s) from any liability under 
copyright law or otherwise.

=head1 AUTHOR

Geoff Westcott. This documentation and parts of the code are
based on various other tv_grabbers from the XMLTV-project.

=head1 COPYRIGHT

Copyright (c) 2014 Geoff Westcott.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
(version 2) as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=head1 SEE ALSO

L<xmltv(5)>.

=cut

